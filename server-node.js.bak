#!/usr/bin/env node
'use strict';

const path = require('path');
const fs = require('fs');
const os = require('os');
const express = require('express');
const mongoose = require('mongoose');
const fsPromises = fs.promises;

const ROOT_DIR = __dirname;
const PORT = parseInt(process.env.PORT || '8000', 10);
const PORTAL_PATH = '/portal';
const API_PATH = '/.well-known/captive-portal';
const ACCEPT_PATH = '/accept';
const DHCP_LEASES_PATH = process.env.DHCP_LEASES_PATH || '/var/lib/misc/dnsmasq.leases';
const LOG_PATH = process.env.LOG_PATH || '';
const MONGO_URI = process.env.MONGO_URI || '';

// Track acceptance by client IP (demo-only)
const ACCEPTED = new Set();

function getLocalIP() {
  const ifaces = os.networkInterfaces();
  for (const name of Object.keys(ifaces)) {
    for (const iface of ifaces[name] || []) {
      if ((iface.family === 'IPv4' || iface.family === 4) && !iface.internal) {
        return iface.address;
      }
    }
  }
  return '127.0.0.1';
}

function portalUrlFromHost(hostHeader) {
  const host = hostHeader || `${getLocalIP()}:${PORT}`;
  return `http://${host}${PORTAL_PATH}`;
}

const app = express();

// If you run behind a reverse proxy, enable trust proxy for correct client IPs
app.set('trust proxy', true);

// Basic no-store for all responses
app.use((req, res, next) => {
  res.set('Cache-Control', 'no-store');
  next();
});

// Optional: connect to MongoDB for request logging
let LogModel = null;
if (MONGO_URI) {
  mongoose
    .connect(MONGO_URI, { dbName: process.env.MONGO_DB || undefined })
    .then(() => {
      const dhcpSchema = new mongoose.Schema(
        {
          source: String,
          mac: String,
          hostname: String,
          expiryEpoch: Number,
        },
        { _id: false }
      );
      const logSchema = new mongoose.Schema(
        {
          ts: { type: Date, index: true },
          method: String,
          path: String,
          clientIP: { type: String, index: true },
          xff: String,
          xffClientIP: String,
          host: String,
          ua: String,
          referer: String,
          status: Number,
          ms: Number,
          dhcp: dhcpSchema,
        },
        { collection: process.env.MONGO_COLLECTION || 'portal_requests' }
      );
      LogModel = mongoose.model('PortalRequest', logSchema);
      console.log('[mongo] connected');
    })
    .catch((err) => {
      console.error('[mongo] connection error:', err.message);
    });
}

// Optional: parse dnsmasq leases file and return info by IP
async function lookupDhcpInfoByIP(ip) {
  try {
    const content = await fsPromises.readFile(DHCP_LEASES_PATH, 'utf8');
    // dnsmasq format: <expiry> <mac> <ip> <hostname> <client-id>
    const lines = content.split('\n');
    for (const line of lines) {
      if (!line.trim()) continue;
      const parts = line.split(/\s+/);
      if (parts.length < 4) continue;
      const [expiry, mac, leaseIp, hostname] = parts;
      if (leaseIp === ip) {
        const exp = Number(expiry);
        return {
          source: 'dnsmasq',
          mac,
          hostname: hostname === '*' ? '' : hostname,
          expiryEpoch: isNaN(exp) ? null : exp,
        };
      }
    }
  } catch (e) {
    // Silently ignore if file not present or unreadable
  }
  return null;
}

// Request logger with optional DHCP metadata
app.use(async (req, res, next) => {
  const start = Date.now();
  const clientIP = req.ip || req.socket.remoteAddress || '';
  const xffRaw = req.headers['x-forwarded-for'] || '';
  const xffClientIP = Array.isArray(xffRaw)
    ? (xffRaw[0] || '')
    : (xffRaw.split(',')[0] || '').trim();
  const dhcp = await lookupDhcpInfoByIP(clientIP);
  const logEntry = {
    ts: new Date(start).toISOString(),
    method: req.method,
    path: req.originalUrl || req.url,
    clientIP,
    xff: xffRaw || '',
    xffClientIP,
    host: req.headers['host'] || '',
    ua: req.headers['user-agent'] || '',
    referer: req.headers['referer'] || req.headers['referrer'] || '',
    dhcp,
  };

  // Write on response finish to capture status and duration
  res.on('finish', () => {
    logEntry.status = res.statusCode;
    logEntry.ms = Date.now() - start;
    const line = JSON.stringify(logEntry);
    console.log(line);
    if (LOG_PATH) {
      fs.appendFile(LOG_PATH, line + '\n', () => {});
    }
    // Fire-and-forget Mongo write
    if (LogModel) {
      try {
        // Avoid blocking the response lifecycle
        Promise.resolve(new LogModel(logEntry).save()).catch(() => {});
      } catch (_) {
        // ignore
      }
    }
  });
  next();
});

// Captive Portal API (RFC 8908)
app.get(API_PATH, (req, res) => {
  const clientIP = req.ip || req.socket.remoteAddress || '';
  const captive = !ACCEPTED.has(clientIP);
  res.type('application/captive+json').send({
    captive,
    'user-portal-url': portalUrlFromHost(req.headers['host'] || ''),
  });
});

// Human portal UI
app.get(PORTAL_PATH, (req, res) => {
  const filePath = path.join(ROOT_DIR, 'index.html');
  if (fs.existsSync(filePath)) {
    res.type('html');
    res.sendFile(filePath);
  } else {
    res.status(404).type('text').send('index.html not found');
  }
});

// Accept endpoint
app.post(ACCEPT_PATH, (req, res) => {
  const clientIP = req.ip || req.socket.remoteAddress || '';
  ACCEPTED.add(clientIP);
  res.status(204).end();
});

// Static files fallback (serve project root)
app.use(express.static(ROOT_DIR, { index: 'index.html', fallthrough: true }));

// 404 handler
app.use((req, res) => {
  res.status(404).type('text').send('Not Found');
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Captive Portal server (Express) running on http://0.0.0.0:${PORT}`);
  console.log(`API: ${API_PATH}`);
  console.log(`Portal: ${PORTAL_PATH}`);
  console.log(`Accept endpoint: ${ACCEPT_PATH}`);
});
